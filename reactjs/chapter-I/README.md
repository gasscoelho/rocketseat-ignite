# Chapter I

This chapter focus on the React fundamentals. It covers important concepts like `Properties`, `States`, `Immutability`, `hooks`. Also, an application was created from scratch using tools such as Webpack, Babel, Webpack Dev Server, SASS, Source Maps, Fast Refresh.

## Table of Contents

1. [Configuring the Environment](#configuring-the-environment)
   1. [Installing React](#installing-react)
   2. [Creating the HTML](#creating-the-html)
   3. [Configuring Babel](#configuring-babel)
   4. [Configuring Webpack](#configuring-webpack)
   5. [ReactJS Structure](#reactjs-structure)
   6. [Serving Static HTML](#serving-static-html)
   7. [Webpack Dev Server](#webpack-dev-server)
   8. [Using Source Maps](#using-source-maps)
   9. [Setting Dev and Prod environments](#setting-dev-and-prod-environments)
   10. [Importing CSS Files](#importing-css-files)
   11. [Using SCSS](#using-scss)
2. [Important Concepts](#important-concepts)
   1. [Components](#components)
   2. [Properties](#properties)
   3. [State](#state)
   4. [Immutability](#immutability)
   5. [Fast Refresh in Webpack](#fast-refresh-in-webpack)
3. [HTTP Calls](#http-calls)
4. [Using Typescript](#using-typescript)
5. [Challenges](#challenges)

## Configuring the Environment

When starting a new JavaScript project, the first thing we have to do after creating the project's folder is to initialize the project by running the `init` command.

```zsh
yarn init -y
```

**Yarn** is a package manager that doubles down as project manager. It allows us to use and share code with other developers from around the world. The code is shared through something called a **package** (sometimes referred to as a **module**). A package contains all the code being shared as well as a `package.json` file which describes the package.

> Yarn is an alternative for `npm`.

### Installing React

Once we have initialized the project, we can install `React` and `React DOM`.

```zsh
yarn add react react-dom
```

Understanding the packages being installed:

* **React** is a JavaScript library for creating user interfaces. The `react` package contains only the functionality necessary to define React components. It's typically used together with a React renderer like `react-dom` for the web, or `react-native` for the native environments (e.g., Android, iOS).
* **React DOM** is responsible for rendering React on the browser. The `react-dom` package serves as the entry point to the DOM and server renderers for React.

We'll notice that a file and a folder got created in the root of the project after installing the dependencies.

* **node_modules** stores all the dependencies' code.
* **yarn.lock** is a file used to store exactly which versions of each dependency were installed. This file is automatically generated and updated when adding, removing, or modifying dependencies in the `package.json` file.

**[⬆ back to top](#table-of-contents)**

### Creating the HTML

To organize the project structure folder, we can create a `public` folder in the root of our project and then, create the `index.html`.

**public/index.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Explore</title>
</head>
<body>

</body>
</html>
```

**[⬆ back to top](#table-of-contents)**

### Configuring Babel

JavaScript is a language that is frequently being updated and because of that, the browser may have difficulty understanding some of these features. With that said, to be able to work with modern JavaScript code we need to use a compiler like Babel.

**Babel** is a toolchain that is mainly used to convert ECMAScript 2015+ code into a backward-compatible version of JavaScript in current and older browsers or environments. In other words, is a JavaScript compiler used to compile the code in a way that makes it possible for the browser to understand it.

In the case of this project, we have to convert React code (JSX) into browser supported JavaScript.

```zsh
yarn add -D @babel/core @babel/cli @babel/preset-env @babel/preset-react
```

> The `-D` flag means that yarn will install these dependencies only for development purposes. In short, these dependencies will not be used in a `production` environment.

Understanding the packages:

* `@babel/core` contains the core functionalities of the Babel compiler.
* `@babel/cli` will install the Babel CLI executable in the **node_modules** folder. This CLI will be used to execute commands which transpiles the code.
* `@babel/preset-env` is a smart preset that allows us to use the latest JavaScript without needing to micromanage which syntax transforms are needed by our target environment. It will identify what environment our application is running so it can make better conversion approaches.
* `@babel/preset-react` is a preset for transpiling React code.

Having installed the Babel dependencies, we shall create a Babel configuration file at the root of the project.

**babel.config.js**

```js
module.exports = {
  presets: [
    '@babel/preset-env',
    '@babel/preset-react'
  ],
};
```

To test the babel, let's create a `src` folder and then, the `index.js` file.

**./src/index.js**

```js
const user = {
  name: 'Gabriel Coelho'
}

console.log(user.address?.street)
```

Now, execute the following code to transpile the code using Babel.

```zsh
yarn babel ./src/index.js --out-file dist/bundle.js
```

Understanding the command:

* `./src/index.js` represents the file location of the code we want to transpile.
* `--out-file` it's a flag used to specify the output for the transpiling code, in this case, **dist/bundle.js** will contain the new code.

**./dist/bundle.js**

![bundle-example-code](https://user-images.githubusercontent.com/33602013/122683913-a0738b00-d1d8-11eb-89c4-6cf27c316e46.png)

**[⬆ back to top](#table-of-contents)**

### Configuring Webpack

**Webpack** is a static module bundler for JavaScript applications. The main purpose is to bundle JavaScript files for usage in a browser. In other words, it takes all the code from our application and makes it usable in a web browser.

![webpack](https://user-images.githubusercontent.com/33602013/122684669-1e399580-d1dd-11eb-8635-84a1df38356a.png)

When Webpack processes our application, it will do a series of process such as building a dependency graph which maps out the modules that our project needs and generates one or more **bundles**. 

> A bundle is a distinct grouping of connected code that has been compiled and transformed for the browser.

Webpack also takes our non-code assets, like images, fonts, styles, and etc, and converts them to dependencies for our application.

To get started with Webpack we need to understand its **core concepts**:

* **Entry**: the entry point for the application. It indicates which module webpack should use to begin building out its internal dependency graph.
* **Output**: tells webpack where to emit the _bundles_ it creates and how to name these files. It defaults to `./dist/main.js` for the main output file and to the `./dist` folder for any other generated file.
* **Loaders**: out of the box, webpack only understands JavaScript and JSON files. Loaders allow webpack to process other types of files and convert them into valid modules that can be consumed by our application and added to the dependency graph. At a high level, loaders have two properties in our webpack configuration:
   * The `test` property identifies which file or files should be transformed.
   * The `use` property  indicates which loader should be used to do the transforming.
* **Plugins**: handle the additional tasks that can't be completed by a loader. This includes things like bundle optimization, asset management, and injection of environment variables.
* **Mode**: enable webpack's built-in optimizations that correspond to each environment. The modes are `development`, `production`, or `none`. The default value is `production`.

Let's install Webpack for our project:

```zsh
yarn add -D webpack webpack-cli
```

Furthermore, to make Babel to work with Webpack, we need to add the `babel-loader`:

```zsh
yarn add -D babel-loader
```

Understanding the packages:

* `webpack` contains the necessary functionalities to bundle JavaScript files for usage in a browser.
* `webpack-cli` enables us to use commands for Webpack.
* `babel-loader` is a Webpack loader for babel.

Similar with Babel, let's create a configuration file for the Webpack:

**webpack.config.js** 

```js
const path = require('path')

module.exports = {
  entry: path.resolve(__dirname, 'src', 'index.jsx'),
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js'
  },
  resolve: {
    extensions: ['.js', '.jsx']
  },
  module: { 
    rules: [
      {
        test: /\.jsx$/,
        exclude: /node_modules/,
        use: 'babel-loader'
      }
    ]
  }
}
``` 

To test the webpack, let's create an `./src/App.jsx` file with our first React code.

**./src/App.jsx**

```js
export function App() {
  return <h1>Hello World!</h1>
}
```

Then, let's rename our `index.js` to `index.jsx`, and change the code to import some `React` code. 

> Since the goal here is to show the webpack functionality, we can just add the `import` declarations.

**./src/index.jsx**

```js
import React from 'react'
import { App } from './App'
```

Save the files and run the following command:

```zsh
yarn webpack
```

**./dist/bundle.js**

![webpack-bundle-example](https://user-images.githubusercontent.com/33602013/122686866-dec57600-d1e9-11eb-9569-38979d73647c.png)

**[⬆ back to top](#table-of-contents)**

### ReactJS Structure

Let's change the `index.jsx` file to render our React content.

**./src/index.jsx**

```js
import { render } from 'react-dom'
import { App } from './App'

render(<App />, document.getElementById('root'))
```

With that, we need to go back to our `index.html` file and add a div element with an id of `root`. Internally, react will wrap all of our React code into that div.

Also, let's import the `bundle.js` in the `script`. Our code should look like this:

**./public/index.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Explore</title>
</head>
<body>
    <div id="root"></div>

    <script src="../dist/bundle.js"></script>
</body>
</html>
```

After that, we can run the webpack and open our `index.html` in the browser.

```zsh
yarn webpack
```

We'll notice in the browser's console that an error happened: `React is not defined`. That's because every file that uses React code must import the React dependency. But this has changed in the latest version of React, and the way to fix this issue is by adding an extra configuration to our babel.config.js. So let's add the new configuration for the `preset-react`:

**babel.config.js**

```js
module.exports = {
  presets: [
    '@babel/preset-env',
    ['@babel/preset-react', {
      runtime: 'automatic'
    }]
  ],
};
```

Save the file, and execute the `yarn webpack` again. The error must be gone and our _Hello World_ message must be appearing on the screen.

![hello-world](https://user-images.githubusercontent.com/33602013/122688302-dffaa100-d1f1-11eb-987f-34f335c95ce1.png)

> Additionally, we can add a `mode: 'development'` property to our **webpack.config.js**. This will increase the time of the bundle in the development process.

**[⬆ back to top](#table-of-contents)**

### Serving Static HTML

Having to manually specify the bundle in the HTML file can be really annoying. In order to improve the development process, install the `html-webpack-plugin`:

```zsh
yarn add -D html-webpack-plugin
```

Once installed, add the **plugin** to the **webpack.config.js** file:

**webpack.config.js**

```js
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  mode: 'development',
  entry: path.resolve(__dirname, 'src', 'index.jsx'),
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js'
  },
  resolve: {
    extensions: ['.js', '.jsx']
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, 'public', 'index.html')
    })
  ],
  module: {
    rules: [
      {
        test: /\.jsx$/,
        exclude: /node_modules/,
        use: 'babel-loader'
      }
    ]
  }
}
```

When we run the `yarn webpack` command again, we'll see that an `index.html` file was created in the `dist` folder.

![dist-example](https://user-images.githubusercontent.com/33602013/122688548-46cc8a00-d1f3-11eb-9e4b-ff2058f09251.png)

**[⬆ back to top](#table-of-contents)**

### Webpack Dev Server

Currently, every time we apply a change to the code, we have to manually run the `yarn webpack` command and refresh the browser to see the changes. To automate this process, we can use the `webpack-dev-server`.

```zsh
yarn add -D webpack-dev-server
```

In short, this dependency will watch our code and every time we make a change, it will create our bundle. In the `webpack.config.js` file, let's add the **devServer** property:

**webpack.config.js**

```js
...
module.exports = {
  mode: 'development',
  ...
  resolve: {
    extensions: ['.js', '.jsx']
  },
  devServer: {
    contentBase: path.resolve(__dirname, 'public')
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, 'public', 'index.html')
    })
  ],
  ...
}
```
Now if we run the `webpack serve` command, we'll see that the application will start in a `localhost:8080`, and that any changes we make to the code will automatically refresh the application.

```zsh
yarn webpack serve
```

**[⬆ back to top](#table-of-contents)**

### Using Source Maps

**Source maps** are decoder rings to our secret (minified) code. It maps from the transformed source to the original source, enabling the browser to reconstruct the original source and present the reconstructed original in the debugger. This can be really helpful for debugging purposes.

To better understand the source maps, let's force an error in the `App.jsx` file.

**./src/App.jsx**

![source-map-error-example](https://user-images.githubusercontent.com/33602013/122688829-e8a0a680-d1f4-11eb-9389-5a81d42881ef.png)

If we go to the browser and click on the **source** tab, we'll notice that the code presented there will not be the same as the one we have in the editor.

![source-map-error-browser-1](https://user-images.githubusercontent.com/33602013/122688832-ec342d80-d1f4-11eb-84a3-fec00628e947.png)

This can make debugging harder. So, to avoid that and to enable the **source maps** in the project, we can just add the `devtool` property in the webpack configuration file:

**webpack.config.js**

```js
...
module.exports = {
  mode: 'development',
  devtool: 'eval-source-map',
  entry: path.resolve(__dirname, 'src', 'index.jsx'),
  ...
}
```

Restart the application and check the browser again. This time, the code should be exactly the same as the one we have in our editor.

![source-map-error-browser-2](https://user-images.githubusercontent.com/33602013/122688835-edfdf100-d1f4-11eb-8fa1-8d2d1a13506f.PNG)


**[⬆ back to top](#table-of-contents)**

### Setting Dev and Prod environments

Let's modify the `webpack.config` file to switch features according to the environment. In this example, we'll be using the `process.env.NODE_ENV` to check if the application is running in a `Dev` or `Prod` environment. 

**webpack.config.js**

```js
const isDevelopment = process.env.NODE_ENV !== 'production'

module.exports = {
  mode: isDevelopment ? 'development' : 'production',
  devtool: isDevelopment ? 'eval-source-map' : 'source-map',
  ...
}
```

Since Unix system and Windows have different ways to set an environment variable, we will use the `cross-env` dependency:

```zsh
yarn add -D cross-env
```

Once installed, we can proceed with the creation of `scripts` in the **package.json** file:

**package.json**

```json
...
"main": "index.js",
"license": "MIT",
"scripts": {
    "dev": "webpack serve",
    "build": "cross-env NODE_ENV=production webpack"
 },
...
```

Understanding the scripts:

* **dev**: runs the webpack serve for development
* **build**: set the `NODE_ENV` to `production` and run the webpack

**[⬆ back to top](#table-of-contents)**

### Importing CSS files

Create a new file in `./src/styles/global.css`:

**./src/styles/global.css**

```scss
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font: Arial, Helvetica, sans-serif;
}
```

Now let's try to import the CSS file in the `App.jsx`:

**./src/App.jsx**

```js
import './styles/global.scss';

...
```

If we try to run the application we'll see a failure. That's because the webpack was not able to understand the CSS import in our file.

![error-import-css](https://user-images.githubusercontent.com/33602013/122699491-e4d64980-d21f-11eb-92be-e7c356c36f3a.png)

To fix that, install the loaders for CSS:

```zsh
yarn add -D style-loader css-loader
```

Understanding the packages:

* `css-loader` interprets **@import** and **url()** like **import/require()** and resolve them. In short, it takes a CSS file and returns the CSS with **imports** and **url()**, but it doesn't actually do anything with the returned CSS.
* `style-loader` injects CSS into the DOM. In other words, it actually inserts the css into the page so that the styles are active on the page.

> Both loaders perform different operations, but it's often useful to chain them together.

Add them to the webpack file:

**webpack.config.js**

```js
module: {
  rules: [
    ...
    {
      test: /\.css$/,
      exclude: /node_modules/,
      use: ['style-loader', 'css-loader']
    },
  ]
}
```

Use `yarn dev` to start the application again and check the new style in the page.

> Remember to remove the fake error that was added in the `App.jsx` file.

![inspect-css](https://user-images.githubusercontent.com/33602013/122699494-e6077680-d21f-11eb-85ac-8919101aa6bd.png)

**[⬆ back to top](#table-of-contents)**

### Using SCSS

Instead of using CSS, let's use a pre-processor called SASS that is an extension of CSS that enables us to use things like variables, nested rules, inline imports, and more.

```zsh
yarn add -D node-sass sass-loader
```

Let's go to the webpack file and change the existing `css rule` to include the SCSS loader:

**webpack.config.js**

```js
module: {
  rules: [
    ...
    {
      test: /\.scss$/,
      exclude: /node_modules/,
      use: ['style-loader', 'css-loader', 'sass-loader']
    },
  ]
}
```

**[⬆ back to top](#table-of-contents)**

## Important Concepts

### Components

Components in React are like Tags in HTML. It's a way to encapsulate the code inside of a single element that will contain its own style and features.

Some conventions when developing components:

* Each component per file
* Always start with an uppercase letter
* It's a good practice to create a `components` folder to stores all the components of the application

In our application, create a folder `src/components/` and a file named `RepositoryList.jsx`.

**./src/components/RepositoryList.jsx**

```js
export function RepositoryList() {
  return (
    <section className="repository-list">
      <h1>Repositories List</h1>

      <ul>
        <li>
          <strong>Repository Name</strong>
          <p>Repository Description</p>

          <a href="http://">Access</a>
        </li>

        <li>
          <strong>Repository Name</strong>
          <p>Repository Description</p>

          <a href="http://">Access</a>
        </li>
      </ul>
    </section>
  )
}
```

Once created, we can add it to the `App.jsx`:

**./src/App.jsx**

```js
import { RepositoryList } from './components/RepositoryList';
import './styles/global.scss';

export function App() {
  return <RepositoryList />
}
```

### Properties

Properties in React works in the same way as the attributes in HTML Tags. They are variables that we pass to the component to change its behavior. In short, the parent components pass information to the children components.

Let's create another component called `RepositoryItem.jsx`:

**./src/components/RepositoryItem.jsx**

```js
export function RepositoryItem(props) {
  return (
    <li>
      <strong>{props.repository.name}</strong>
      <p>{props.repository.description}</p>

      <a href={props.repository.link}>Access</a>
    </li>
  );
}
```

Once done, go back to the `RepositoryList` and change the `<li>` blocks to use the new component:

**./src/components/RepositoryList.jsx**

```js
import { RepositoryItem } from "./RepositoryItem"

const dbtRepository = {
  name: 'dbt',
  description: 'A transformation tool.', 
  link: 'https://github.com/'
}

const jenkinsRepository = {
  name: 'Jenkins',
  description: 'Implement a CI/CD with Jenkins.', 
  link: 'https://github.com/'
}

export function RepositoryList() {
  return (
    <section className="repository-list">
      <h1>Repositories List</h1>

      <ul>
        <RepositoryItem repository={dbtRepository} />
        <RepositoryItem repository={jenkinsRepository}/>
      </ul>
    </section>
  )
}
```

> Note that in this example we are creating objects for each repository and passing them to the child component.

### State

The state is a really important concept in React that enables us to change a value of a variable and automatically render it on the screen if needed. In short, the state of a component is an object that holds information that may change over the lifetime of the component.

In react, we use the `useState` hook. This hook receives a value to initialize the variable. It returns an array where the first index is the "variable" and the second index is a function used to update the value of this variable. For example:

```js
import { useState } from 'react'

export function Counter() {
  const [counter, setCounter] = useState(0)

  function increment() {
    setCounter(counter + 1)
  }

  return (
    <div>
      <h1>{counter}</h1>
      <button type="button" onClick={increment}>
        Increment
      </button>
    </div>
  )
}
```

> Note that the example above is just a demonstration of how to use the `useState` hook. We don't need to create it in the application.

### Immutability

In programming, a variable is immutable when its value cannot change after it’s created. An immutable variable can never be changed. To update its value, you create a new variable.

In React this applies in many places, specially for states.

There are various reasons, the most important of which are:

* Code looks cleaner and simpler to understand. You never expect a function to change some value without you knowing, which gives you predictability. When a function does not mutate objects but just returns a new object, it’s called a pure function.
* The library can optimize the code because for example JavaScript is faster when swapping an old object reference for an entirely new object, rather than mutating an existing object. This gives you performance.

### Fast Refresh in Webpack

This dependency is used when we want to refresh the screen without resetting the state of our variables. For instance, a really common issue is that when we add/change the code that and it triggers the load of the screen, all of our `useState` gets restarted. So, if we want to avoid that, we need to use this dependency.

```zsh
yarn add -D @pmmmwh/react-refresh-webpack-plugin react-refresh
```

Go to `webpack.config.js` and add the new plugin:

**./webpack.config.js**

```js
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const ReactRefreshWebpackPlugin = require('@pmmmwh/react-refresh-webpack-plugin')

const isDevelopment = process.env.NODE_ENV !== 'production'

module.exports = {
  mode: isDevelopment ? 'development' : 'production',
  devtool: isDevelopment ? 'eval-source-map' : 'source-map',
  entry: path.resolve(__dirname, 'src', 'index.jsx'),
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js'
  },
  resolve: {
    extensions: ['.js', '.jsx']
  },
  devServer: {
    contentBase: path.resolve(__dirname, 'public'),
    hot: true
  },
  plugins: [
    isDevelopment && new ReactRefreshWebpackPlugin(),
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, 'public', 'index.html')
    })
  ].filter(Boolean),
  module: {
    rules: [
      {
        test: /\.jsx$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            plugins: [
              isDevelopment && require.resolve('react-refresh/babel')
            ].filter(Boolean)
          }
        }
      },
      {
        test: /\.scss$/,
        exclude: /node_modules/,
        use: ['style-loader', 'css-loader', 'sass-loader']
      },
    ]
  }
}
```

**[⬆ back to top](#table-of-contents)**

## HTTP Calls

**[⬆ back to top](#table-of-contents)**

## Using Typescript

**[⬆ back to top](#table-of-contents)**

## Challenges

- <a href="https://github.com/gasscoelho/ignite-challenge-react-concepts" target="_blank">React Concepts</a>
- <a href="https://github.com/gasscoelho/ignite-challenge-componentizing-the-application" target="_blank">Componentizing the Application</a>

**[⬆ back to top](#table-of-contents)**